= Applications using the Sensor Hierarchy =

The primary application is a data logger --- a process that
periodicaly scans a configured set of sensors, and logs their reports
into a database.

(As this is the only application so far, we document it here. To be
moved out if need be.)

== Data Logger ==

[http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/docs/Datalogger-UML.png]

=== The !DataStore Interface and its Responsibilities ===

We use a "!DataStore" class to abstract away databases. Nobody wants
to carry the burden of a database when, for example, hacking on a
visualization GUI.

A data store's job is to

 * store samples
 * retrieve samples

The store is filled by somebody who produces samples at a regular
interval. Pythonically, one can imagine that the following code
fragment would produce one sample.

{{{
import datetime

try:
    temperature = t.get_temperature()
    status = 0
except Thermometer.Error as e:
    temperature = 0.0
    status = e.status

sample = (datetime.datetime.utcnow(), 
          "Sensor in the third row, middle, bottom",
	  temperature,
          status)
store.add_sample(sample)
}}}

Samples are retrieved based on a range like so,

{{{
samples = store.get_samples(from, to)
}}}

where {{{from}}} and {{{to}}} are {{{datetime.datetime}}} objects. If
either end is unspecified, it is passed as {{{None}}}. Note that the
store may choose to raise an exception if the number of samples in the
specified range is too high. In this case, the user has to split the
desired range into multiple smaller ranges and retrieve those one by
one.

=== SQLite3 !DataStore Incarnation ===

The "real life" incarnation of a data store maintains a SQLite3
database. The database has a single table "samples" which is set up to
contain the sample tuples.

{{{
create table samples (
  timestamp datetime,
  sensorname varchar(30),
  temperature real,
  status int
)
}}}

A single process is dedicated to filling the database. Note that
SQLite3 supports access to a database from multiple processes, but
only one of those can write to it. (See [here
http://www.sqlite.org/faq.html#q5] for the whole story.)

This retriction is fine for us --- we can have multiple readers, which
is what we will.