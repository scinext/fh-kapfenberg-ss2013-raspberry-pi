<wiki:toc max_depth="1" />

= Sensors =

*Todo*

|| Stefan Winkler, Martin Steinbauer || Fix LM73 {{{set_resolution()}}} ||
|| ??? || LM73: {{{get_temperature()}}} does not respect resolution from Control/Status register ||

 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-LM73.pdf LM73]*. We have an implementation (by Helmut Kopf and Patrick Gröller) that can
   * Convert the temperature register based on the precision configuration from the "control/status" register
   * Configure the precision (set the "control/status" register)
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-TC74.pdf TC74]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-AD741x.pdf AD7414]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempHumiSensor-HYT221-Protokollbeschreibung_DE.pdf HYT221]*. Done (to be verified).

= Temperature Sample Database =

Done (the reader side still to be verified).

We have an [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStore.py interface], 
and both [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStoreInMemory.py an in-memory]
and [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStoreSQL.py a SQL] implementation. The latter uses [http://www.python.org/dev/peps/pep-0249/ Python's DBAPI2] which decouples it from any concrete database. In the project, SQLite3 is used as a database.

= Sample Acquisition =

*Todo*

|| Martin Krainer, Markus Koller || Write unit tests for ParallelSampleCollector, using DataStoreInMemory ||

A [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/services/parallelSampleCollector.py parallelized (using multiple processes) temperature sample acquisition] is in place.

A main program does database and sensors setup, and then drives the
main loop of the acquisition. A [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/programlooper.py Python generator is used to control the loop] and, most important, its termination using a signal handler.

A couple of unit tests are still to be written to test several aspects such as

 * Regular operation of a couple of sensors
 * Error scenarios:
   * IOError on a sensor (can be simulated; write a dedicated sensor that always throws)
   * what else?

= Temperature Sample Server =

*Todo*

|| Patrick Gröller || Rewrite XML to *use* {{{DataStore}}} interface; test using {{{DataStoreInMemory}}} ||
|| Helmut Kopf || Review the callback mechanism where threads are (un)registered (locking issues) ||
|| Florian Dulzky, Markus Neubauer || Real-life final _program_ ||

*The network part* is basically done. The [code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/network/tempserver.py server class] is parallel and handles each command in a dedicated thread.

*XML* needs a little help, should use the {{{DataStore}}}
interface. This gets us rid of the external XML file that is currently
used.

*The real-life final program* will

 * Fullfill requests from a database (presumably from the same database that is filled by the acquisition program)
 * Provide a "dummy" option for easy operation, for use by the Android client developer(s).
 * Use the {{{argparse}}} module to interpret commandline parameters

Use [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/programs/temperature-server.py this] as a starting point.

= Android App =

*Todo*

|| Ludwig Lindlbauer || Write it ||
