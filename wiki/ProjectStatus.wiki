<wiki:toc max_depth="1" />

= Sensors =

 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-LM73.pdf LM73]*. We have an implementation (by Helmut Kopf and Patrick Gröller) that can
   * Convert the temperature register based on the precision configuration from the "control/status" register
   * Configure the precision (set the "control/status" register)
   Stefan Winkler does some final checking (there are problems setting the precision)
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-TC74.pdf TC74]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-AD741x.pdf AD7414]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempHumiSensor-HYT221-Protokollbeschreibung_DE.pdf HYT221]*. Done (to be verified).

= Temperature Sample Database =

*Todo*

|| Florian Maderbacher || DataStoreSQLite refactoring ||
|| ??? || DataStoreInMemory ||

A
[http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/services/dataStore.py DataStore interface] is in place.

The [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/services/dataStoreSQLite.py SQLite3 implementation] needs some rework. It currently uses a
module, {{{DBProvider}}}, which is global. Goal is to

 * Instantiate the database connection in the program, right after argument parsing
 * Construct {{{DataStoreSQLite}}} with an existing database connection. This decouples {{{DataStoreSQLite}}} from any concrete database.
 * Use the {{{DataStore}}} object in the remaining parts of the project (acquisition, server, see below).

Like so,

{{{
db = sqlite3.connect("/var/db/sample.db")
store = DataStoreSQLite(db)
...
}}}

An in-memory {{{DataStore}}} incarnation is upcoming, we will use it
for unit tests.

{{{
store = DataStoreInMemory()
}}}

= Sample Acquisition =

*Todo*

|| Robert Angerer || rewrite ParallelSampleCollector to use DataStore like in the pseudo code above ||
|| Robert Angerer || rewrite ParallelSampleCollector to use external iterable in {{{run()}}} method ||
|| ??? || Write iterable that sleeps and uses signal handler ||
|| ??? || Write unit tests, using DataStoreInMemory ||
|| ??? || Real-life final _program_ ||

A (parallel) sample collector is in place. It currently has problems
with the database access, for the reasons mentioned. Needs testing badly, to be done when database access has become
easy. 

*Getting rid of global database*. Should be re-written soon to be
usable like so,

{{{
...
store = DataStoreSQL(db)
collector = ParallelSampleCollector(
    store=store,
    sensorList={"th1": CyclicThermometer((1, 2, 3)), 
                "th2": CyclicThermometer((4, 5, 6))
                },
    )
...
}}}

*Unit tests* could create an easier store,

{{{
store = DataStoreInMemory()
...
}}}

*Iteration, loop control*. Unit tests want it to do, say, five rounds
of acquisition, then stop and examime the result (database or
in-memory). Real life wants something more elaborate: iteration that
sleeps and does signal handling.

*The real-life final program* will

 * Fill a database every n seconds or so (a configurable amount of time)
 * Use a signal handler to stop acquisition.
 * Use the {{{argparse}}} module to interpret commandline parameters

= Temperature Sample Server =

*Todo*

|| Patrick Gröller || Rewrite XML to *use* {{{DataStore}}} interface; test using {{{DataStoreInMemory}}} ||
|| ??? || Add signal handling to quit the main loop and drop out of the {{{start()}}} method ||
|| ??? || Real-life final _program_ ||

*The network part* is basically done. It uses threading, but that's a
minor issue :-)

*XML* needs a little help, should use the {{{DataStore}}}
interface. This gets us rid of the external XML file that is currently
used.

*The real-life final program* will

 * Fullfill requests from a database (presumably from the same database that is filled by the acquisition program)
 * Provide a "dummy" option for easy operation, for use by the Android client developer(s).
 * Use the {{{argparse}}} module to interpret commandline parameters
