<wiki:toc max_depth="1" />

= Sensors =

*Todo*

|| Stefan Winkler, Martin Steinbauer || Fix LM73 {{{set_resolution()}}} ||
|| ??? || LM73: {{{get_temperature()}}} does not respect resolution from Control/Status register ||

 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-LM73.pdf LM73]*. We have an implementation (by Helmut Kopf and Patrick Gröller) that can
   * Convert the temperature register based on the precision configuration from the "control/status" register
   * Configure the precision (set the "control/status" register)
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-TC74.pdf TC74]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempSensor-AD741x.pdf AD7414]*. Done (to be verified).
 * *[http://fh-kapfenberg-ss2013-raspberry-pi.googlecode.com/svn/trunk/docs/TempHumiSensor-HYT221-Protokollbeschreibung_DE.pdf HYT221]*. Done (to be verified).

= Temperature Sample Database =

Done (the reader side still to be verified).

We have an [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStore.py interface], 
and both [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStoreInMemory.py an in-memory]
and [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/libthermalraspi/database/DataStoreSQL.py a SQL] implementation. The latter uses [http://www.python.org/dev/peps/pep-0249/ Python's DBAPI2] which decouples it from any concrete database. In the project, SQLite3 is used as a database.

= Sample Acquisition =

*Todo*

|| Michaela Maierhofer, Bernadette Pecovnik, Robert Pürer || Write iterable that sleeps and uses signal handler ||
|| Mario Pflegpeter || Read sensor configuration file into dictionary (incl. unit test(s)) ||
|| Martin Krainer, Markus Koller || Write unit tests for ParallelSampleCollector, using DataStoreInMemory ||
|| Florian Dulzky, Markus Neubauer || Real-life final _program_ ||

A (parallel) sample collector is in place. It currently has problems
with the database access, for the reasons mentioned. Needs testing badly, to be done when database access has become
easy. 

*Getting rid of global database*. Should be re-written soon to be
usable like so,

{{{
...
store = DataStoreSQL(db)
collector = ParallelSampleCollector(
    store=store,
    sensorList={"th1": CyclicThermometer((1, 2, 3)), 
                "th2": CyclicThermometer((4, 5, 6))
                },
    )
...
}}}

*Sensor configuration*. What about reading a config file _in Python
syntax_, using the {{{eval}}} statement? The config file would look like this,

{{{
{
  'th-links-oben': LM73(1, 49),
  'th-rechts-unten': Proxy('192.168.1.109', 1234),
}
}}}

*Unit tests* could create an easier store,

{{{
store = DataStoreInMemory()
}}}

A couple of unit tests should be written to test several aspects

 * Regular operation of a couple of sensors
 * Error scenarios:
   * IOError on a sensor (can be simulated; write a dedicated sensor that always throws)
   * what else?

*Iteration, loop control*. Unit tests want it to do, say, five rounds
of acquisition, then stop and examine the result (database or
in-memory). Real life wants something more elaborate: iteration that
sleeps and does signal handling.

See [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/programs/looper-example.py here] for an example.

*The real-life final program* will

 * Fill a database every n seconds or so (a configurable amount of time)
 * Use a signal handler to stop acquisition.
 * Use the {{{argparse}}} module to interpret commandline parameters

Use [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/programs/temperature-acquisition.py this] as a starting point.

= Temperature Sample Server =

*Todo*

|| Patrick Gröller || Rewrite XML to *use* {{{DataStore}}} interface; test using {{{DataStoreInMemory}}} ||
|| Helmut Kopf || Add signal handling to quit the main loop and drop out of the {{{start()}}} method ||
|| Florian Dulzky, Markus Neubauer || Real-life final _program_ ||

*The network part* is basically done. It uses threading, but that's a
minor issue :-)

*XML* needs a little help, should use the {{{DataStore}}}
interface. This gets us rid of the external XML file that is currently
used.

*The real-life final program* will

 * Fullfill requests from a database (presumably from the same database that is filled by the acquisition program)
 * Provide a "dummy" option for easy operation, for use by the Android client developer(s).
 * Use the {{{argparse}}} module to interpret commandline parameters

Use [http://code.google.com/p/fh-kapfenberg-ss2013-raspberry-pi/source/browse/trunk/programs/temperature-server.py this] as a starting point.